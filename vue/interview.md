# 目录
- [1、高度塌陷](#1-什么情况下会出现高度坍塌以及怎么解决)
- [2、BFC](#2-BFC)
- [3、什么是深拷贝和浅拷贝?以及怎么实现深拷贝和浅拷贝](#3-什么是深拷贝和浅拷贝?以及怎么实现深拷贝和浅拷贝)
- [4、什么是事件循环](#4-事件循环)
- [5、localStorage、sessionStorage、cookies有什么区别](#5-localStorage、sessionStorage、cookies有什么区别)
- [6、Set和Map有什么区别](#6-Set和Map有什么区别)
- [7、箭头函数和普通函数有什么区别](#7-箭头函数和普通函数有什么区别?)
- [8、简单说说一下两链一包](#8-简单说说一下两链一包)
- [9、promise](#9-promise)
    - [1、什么是Promise]
    - [2、promise是不是最佳解决方案]
    - [3、多个async\await如何优化]
- [10、说说你对SPA单页面的理解，它的优缺点分别是什么](#10-说说你对SPA单页面的理解，它的优缺点分别是什么)
- [11、v-model的原理](#11-v-model的原理)
- [12、compute和watch的区别](#12-compute和watch的区别)
- [13、Vue的父组件和子组件生命周期钩子函数执行顺序](#13-vue的父组件和子组件生命周期钩子函数执行顺序)
- [14、为什么created钩子函数中更适合调用异步请求](#14-为什么created钩子函数中更适合调用异步请求)
- [15、Vue框架怎么实现对象和数组的监听](#15-vue框架怎么实现对象和数组的监听)
- [16、虚拟DOM和diff算法](#16-虚拟DOM和diff算法)
- [17、能说下vue-router中常用的hash和history路由模式实现原理吗](#17-能说下vue-router中常用的hash和history路由模式实现原理吗)
- [18、Vue项目优化](#18-vue项目优化)
- [19、说说你使用Vue框架踩过最大的坑是什么？怎么解决的](#19-说说你使用Vue框架踩过最大的坑是什么？怎么解决的)
<br/><br/>

# 1. 什么情况下会出现高度坍塌以及怎么解决
<br/><br/>

    出现高度塌陷的情况有两种：
    
    一、子元素设置为float，父元素没有设置高度
    二、子元素设置了position：absolute，父元素没有设置高度
    
    解决办法
    针对第一种情况：清除浮动，父元素设置高度，BFC
    针对第二种情况: 给父元素设置高度。
    
    绝对定位和浮动的区别都会破坏文档流，他们的区别是什么
    
    浮动时：文档流的其他内容不会忽略浮动的位置，会绕开；
    绝对定位时：文档流的其他内容会忽略浮动的位置，会占据；

<br/><br/>

# 2. BFC
 
## 1、什么是BFC
    官方定义：BFC（Block Formatting Context）块格式化上下文， 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。
    
    通俗来说：BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素
 
## 2、创建一个BFC的方法
    常用的方式有以下几种：
    
    浮动元素（元素的float不是 none，指定float为left或者right就可以创建BFC）
    绝对定位元素（元素的 position 为 absolute 或 fixed）
    display:inline-block，display:table-cell，display:flex，display:inline-flex
    overflow指定除了visible的值
 
## 3、BFC有什么特点
    在BFC中，块级元素从顶端开始垂直地一个接一个的排列。（当然了，即便不在BFC里块级元素也会垂直排列）
    如果两个块级元素属于同一个BFC，它们的上下margin会重叠（或者说折叠），以较大的为准。但是如果两个块级元素分别在不同的BFC中，它们的上下边距就不会重叠了，而是两者之和。
    BFC的区域不会与浮动的元素区域重叠，也就是说不会与浮动盒子产生交集，而是紧贴浮动边缘。
    计算BFC的高度时，浮动元素也参与计算。BFC可以包含浮动元素。（利用这个特性可以清除浮动）
    BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。
<br/><br/>
 
# 3. 什么是深拷贝和浅拷贝?以及怎么实现深拷贝和浅拷贝

    浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

    深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。

    浅拷贝的实现方式
    1.Object.assign()
    2.函数库lodash的_.clone方法
    3.展开运算符...
    4.Array.prototype.slice()…

    深拷贝的实现方式
    1.JSON.parse(JSON.stringify())
    2.三方库自带的方法 lodash的_.cloneDeep方法 jQuery.extend()方法
    3.手写递归方法
<br/><br/>

# 4. 事件循环
    JavaScript是单线程的编程语言，只能同一时间内做一件事。但是在遇到异步事件的时候，js线程并没有阻塞，还会继续执行。这是因为JS有事件循环机制。

    js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。

执行站 计时线程 事件队列

https://zhuanlan.zhihu.com/p/33058983
<br/><br/>

# 5. localStorage、sessionStorage、cookies有什么区别？
  
   
## 1、cookie在浏览器与服务器之间来回传递

    sessionStorage和localStorage不会把数据发给服务器，仅在本地保存

## 2、数据有效期不同

    cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭

    sessionStorage：仅在当前浏览器窗口关闭前有效

    localStorage 始终有效，长期保存

## 3、cookie数据还有路径的概念
 
    可以限制cookie只属于某个路径下存储大小也不同，cookie数据不能超4k，sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大

## 4、作用域不用

    sessionStorage不在不同的浏览器窗口中共享

    localStorage在所有同源窗口中都是共享的

    cookie也是在所有同源窗口中都是共享的


https://blog.csdn.net/weixin_47220950/article/details/116029708
<br/><br/>

# 6. Set和Map有什么区别
 
    1、Map是键值对，Set是值得集合，当然键和值可以是任何得值
    2、Map可以通过get方法获取值，而set不能因为它只有值
    3、都能通过迭代器进行for...of 遍历
    4、Set的值是唯一的可以做数组去重，而Map由于没有格式限制，可以做数据存储
<br/><br/>

# 7. 箭头函数和普通函数有什么区别
 
    1、箭头函数比普通函数更加简洁
    如果没有参数，就直接写一个空括号即可
    如果只有一个参数，可以省去参数括号
    如果有多个参数，用逗号分割
    如果函数体的返回值只有一句，可以省略大括号
    如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常用的就是调用一个函数：
    let fn = () => void doesNotReturn()
     
    2 箭头函数没有自己的this
    箭头函数不会创建自己的this,所以它没有自己的this,它只会在自己作用域的上一层继承this。所以箭头函数中的this的指向在它在定义时一旦确定了，之后不会改变。
  
    3、箭头函数继承来的this指向永远不会改变
 
    4、 call()、apply()、bind()等方法不能改变箭头函数中的this指向 
  
    5、箭头函数不能作为构造函数使用
  
    6、箭头函数没有自己的arguments
  
    7、箭头函数没有prototype
  
    8、箭头函数不能用作Generator函数,不能使用yeild关键字
<br/><br/>

# 8. 简单说说一下两链一包
    1)、作用域链
    作用域链实际上就是一种查找方式
    在内部函数中查找变量的时候，优先从函数内部自身查找，如果没有查到，则向外层查找，如果外层还没有，则继续向上一层查找，一直查询到全局作用域。这种链式的查找方式就是作用域链。值得注意的是： 函数内部也会发生变量提升。并且严格遵照js自上而下的执行顺序。

    2)、原型链
    原型链是一种机制，指的是JavaScript每个对象包括原型对象都有一个内置的[[proto]]属性指向创建它的函数对象的原型对象，即prototype属性，其实也是一种查找方式。
    当我们找一个对象的属性时：

        优先从对象自身查找；
        然后从对象的构造函数中查找；
        然后从构造函数的原型对象上查找；
        然后从原型对象的构造函数中查找；
        ….
        然后就是万物祖宗 Object；
        Object 的原型对象；
        Object 原型对象的原型对象 null；（万物皆空）

    3)、闭包    
    如果一个函数访问了此函数的父级及父级以上的作用域变量，那么这个函数就是一个闭包。(理论上来讲，每个函数都是闭包，因为每个函数都能访问全局变量。)

    特点：
    1.被闭包函数访问的父级及以上的函数的局部变量（如范例中的局部变量 i ）会一直存在于内存中，不会被JS的垃圾回收机制回收。
    2.闭包函数实现了对其他函数内部变量的访问。（函数内部的变量对外是无法访问的，闭包通过这种变通的方法，实现了访问。）

    用途：
    访问函数内部的变量
    让变量始终保持在内存中

    优点
    可以减少全局变量的定义，避免全局变量的污染
    能够读取函数内部的变量
    在内存中维护一个变量，可以用做缓存

    闭包的缺点
    1）造成内存泄露
    闭包会使函数中的变量一直保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。
    解决方法——使用完变量后，手动将它赋值为null；

    2）闭包可能在父函数外部，改变父函数内部变量的值。
     
    3）造成性能损失
    由于闭包涉及跨作用域的访问，所以会导致性能损失。
    解决方法——通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响

https://blog.csdn.net/Errrl/article/details/104005912
<br/><br/>

# 9. promise
    1、什么是Promise
    Promise是ES6异步编程的一种解决方案(目前最先进的解决方案是async和await的搭配（ES8），但是它们是基于promise的)，从语法上讲，Promise是一个对象或者说是构造函数，用来封装异步操作并可以获取其成功或失败的结果。

    2、为什么要使用promise
    最重要也是最主要的一个场景就是ajax和axios请求。通俗来说，由于网速的不同，可能你得到返回值的时间也是不同的，但是我们下一步要执行的代码依赖于上一次请求返回值，这个时候我们就需要等待，结果出来了之后才知道怎么样继续下去。 

    3、promise的好处
    防止出现回调地狱；
    提高代码的可读性；
    像同步操作那样去执行异步操作

    4、promise的三种状态
    1).pending: 等待中，或者进行中，表示还没有得到结果
    2).resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行
    3).rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行 

    5、promise的用法 
    1).promise的实例方法

    ①then()      得到异步任务的正确结果
    ②catch()    获取异常信息
    ③finally()   成功与否都会执行(尚且不是正式标准)

    2).promise的对象方法(p1,p2,p3为promise的实例对象)

    ①Promise.all()  并发处理多个异步任务，所有任务都执行完成才能得到结果
    ②Promise.race()  并发处理多个异步任务，只要有一个任务完成就能得到结果
<br/><br/>

# 10. 说说你对SPA单页面的理解，它的优缺点分别是什么
    
    SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
    优点：
    用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；

    基于上面一点，SPA 相对对服务器压力小；

    前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

    缺点：
    初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；

    前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；

    SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

<br/><br/>

# 11. v-model的原理
    v-model其实是一个语法糖，它会自动的在元素或者组件上面解析为 :value="" 和 @input=""， 就像下面这样

```js
    <template>
        <div>
            <div>{{msg}}</div>
            <input type="text" :value="msg" @input="input">
        </div>
    </template>
    <script>
        export default {
            data() {
                return {
                    msg:'123'
                }
            },
            methods: {
                input(e){
                    this.msg=e.target.value

                }
            },  
        }
    </script>
```
    1.当在input输入框输入内容时，会自动的触发input事件，更新绑定的msg值。
    2.当msg的值通过JavaScript改变时，会更新input的value值
<br/><br/>

# 12. compute和watch的区别

    computed： 
        
    是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；
    watch： 
        
    更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

    运用场景：
        
    当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；

    当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。
<br/><br/>

# 13. vue的父组件和子组件生命周期钩子函数执行顺序
 
    Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：

    加载渲染过程：
    父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted
     
    子组件更新过程：
    父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated
     
    父组件更新过程：
    父 beforeUpdate -> 父 updated
      
    销毁过程：
    父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed
<br/><br/>

# 14. 为什么created钩子函数中更适合调用异步请求

    可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：
      
    能更快获取到服务端数据，减少页面 loading 时间；
    ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；  
<br/><br/>

# 15. vue框架怎么实现对象和数组的监听
    如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持。
    同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：
 
  
```js
    * Observe a list of Array items.
    */
    observeArray (items: Array<any>) {
        for (let i = 0, l = items.length; i < l; i++) {
        observe(items[i])  // observe 功能为监测数据的变化
        }
    }

    /**
    * 对属性进行递归遍历
    */
    let childOb = !shallow && observe(val) // observe 功能为监测数据的变化
```   

    通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。
<br/><br/>
  
# 16. 虚拟DOM和diff算法
    虚拟 DOM 的实现原理主要包括以下 3 部分：
     
    用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
    diff 算法 — 比较两棵虚拟 DOM 树的差异；
    pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。

    虚拟DOM优点：
    
    保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；

    无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；

    跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

    缺点:
     
    无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。

    diff算法：

    diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。
    也就是说，diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁
    
        两个特点：

        比较只会在同层级进行, 不会跨层级比较
        在diff比较的过程中，循环从两边向中间比较

    https://blog.csdn.net/weixin_43638968/article/details/112686317    
<br/><br/>

# 17. 能说下vue-router中常用的hash和history路由模式实现原理吗
    hash 模式的实现原理：
     
    早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。
    比如下面这个网站，它的 location.hash 的值为 '#search'：
    https://www.word.com#search
      
    hash 路由模式的实现主要是基于下面几个特性：
     
    URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
    hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
    可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
    我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。

    history 模式的实现原理： 
     
    HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。
    唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：
    window.history.pushState(null, null, path);
    window.history.replaceState(null, null, path);
     
    history 路由模式的实现主要基于存在下面几个特性：
     
    pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
    我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；
    history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。

    两者不同点

    1.原理不同。
    hash模式的实现原理是通过监听hashChange事件来实现的，前端js把当前hash地址对应的组件渲染到浏览器中。history模式是通过调用 history.pushState方法(或者replaceState) 并且 监听popstate事件来实现的。history.pushState会追加历史记录，并更换地址栏地址信息，但是页面不会刷新，需要手动调用地址变化之后的处理函数，并在处理函数内部决定跳转逻辑；监听popstate事件是为了响应浏览器的前进后退功能。

    2.表现不同。
    hash模式会在地址栏中有#号，而history模式没有；同时由于history模式的实现原理用到H5的新特性，所以它对浏览器的兼容性有要求(IE >= 10)。

    3.history模式特点
    history模式开发的SPA项目，需要服务器端做额外的配置，否则会出现刷新白屏（链接分享失效）。原因是页面刷新时，浏览器会向服务器真的发出对这个地址的请求，而这个文件资源又不存在，所以就报404。处理方式就由后端做一个保底映射:所有的请求全部拦截到index.html上。

    总结：
    单页应用是在移动互联时代诞生的，它的目标是不刷新整体页面，通过地址栏中的变化来决定内容区域显示什么内容。要达成这个目标，我们要用到前端路由技术，具体来说有两种方式来实现：hash模式和history模式。hash模式是通过监听hashChange事件来实现的，history模式是通过pushState方法+popstate事件来实现的。
<br/><br/>

# 18. vue项目优化

   （1）代码层面的优化
    v-if 和 v-show 区分使用场景

    computed 和 watch 区分使用场景

    v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

    长列表性能优化

    事件的销毁

    图片资源懒加载

    路由懒加载

    第三方插件的按需引入

    优化无限列表性能

    服务端渲染 SSR or 预渲染

    （2）Webpack 层面的优化
    Webpack 对图片进行压缩

    减少 ES6 转为 ES5 的冗余代码

    提取公共代码

    模板预编译

    提取组件的 CSS

    优化 SourceMap

    构建结果输出分析

    Vue 项目的编译优化

    （3）基础的 Web 技术的优化
    开启 gzip 压缩

    浏览器缓存

    CDN 的使用

    使用 Chrome Performance 查找性能瓶颈
<br/><br/>

# 19. 说说你使用Vue框架踩过最大的坑是什么？怎么解决的    
      
